### 							java并发编程

#### 一.  java并发出现问题的原因

   1. 缓存导致的可见性问题	
   2. 线程切换导致的原子性问题
   3. 编译优化带来的有序性问题

#### 二. java内存模型

   1. 什么是java内存模型：
      ​        现代计算机体系大部是采用的对称多处理器的体系架构。每个处理器均有独立的寄存器组和缓存，多个处理器可同时执行同一进程中的不同线程，这里称为处理器的乱序执行。在Java中，不同的线程可能访问同一个共享或共享变量。如果任由编译器或处理器对这些访问进行优化的话，很有可能出现无法想象的问题，这里称为编译器的重排序。除了处理器的乱序执行、编译器的重排序，还有内存系统的重排序。因此Java语言规范引入了Java内存模型，通过定义多项规则对编译器和处理器进行限制，主要是针对可见性和有序性。

   2. 三个基本原则：原子性、可见性、有序性。

   3. Java内存模型涉及的几个关键词：锁、volatile字段、final修饰符与对象的安全发布。

      ```
      	第一是锁，锁操作是具备happens-before关系的，解锁操作happens-before之后对同一把锁的加锁操作。实际上，在解锁的时候，JVM需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。
      	第二是volatile字段，volatile字段可以看成是一种不保证原子性的同步但保证可见性的特性，其性能往往是优于锁操作的。但是，频繁地访问 volatile字段也会出现因为不断地强制刷新缓存而影响程序的性能的问题。
      	第三是final修饰符，final修饰的实例字段则是涉及到新建对象的发布问题。当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的。
      ```

   4. **Happens-Before的7个规则**（前面一个操作的结果对后续操作是可见的）

      ```
      	(1).程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
      	(2).管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而"后面"是指时间上的先后顺序。
      	(3).volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的"后面"同样是指时间上的先后顺序。
      	(4).线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。
      	(5).线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。
      	(6).线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
      	(7).对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。
      ```

   5. Happens-Before的1个特性：传递性。

   6. Java内存模型底层怎么实现的？主要是通过内存屏障(memory barrier)禁止重排序的，即时编译器根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。对于编译器而言，内存屏障将限制它所能做的重排序优化。而对于处理器而言，内存屏障将会导致缓存的刷新操作。比如，对于volatile，编译器将在volatile字段的读写操作前后各插入一些内存屏障。

#### 三. 锁

​	同一时刻只有一个线程执行-------------------------------互斥。

​	受保护资源和锁之间的关系是N:1的关系。

​	加锁的本质就是在锁定的对象的对象头中写入当前线程的id。

​        **死锁**的一个比较专业的定义是：一组互相竞争资源 的线程因互相等待，导致“永久”阻塞的现象。同时出现一下条件就会出现死锁：

        1. 互斥，共享资源 X 和 Y 只能被一个线程占用； 
        2. 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
        3. 不可抢占，其他线程不能强行抢占线程 T1 占有的资源； 
        4. 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等 待。

解决办法：破坏其中一个条件即可避免死锁的发生

```
   1. 对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。 
   2. 对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可 以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。 
   3. 对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性 顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不 存在循环了。
```

#### 四. 并发编程宏观设计	

​	并发编程是一个复杂的技术领域，微观上涉及到原子性问题、可见性问题和有序性问题，宏观则 表现为安全性、活跃性以及性能问题。
​	我们在设计并发程序的时候，主要是从宏观出发，也就是要重点关注它的安全性、活跃性以及性能。安全性方面要注意数据竞争和竞态条件，活跃性方面需要注意死锁、活锁、饥饿等问题，性能方面我们虽然介绍了两个方案，但是遇到具体问题，你还是要具体分析，根据特定的场景选择 合适的数据结构和算法。

```
当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候，如果我们不采取防护 措施，那么就会导致并发 Bug，对此还有一个专业的术语，叫做数据竞争

谓竞态条件，指的是程序的执行结果依赖线程执行的顺序。get()方法

解决性能的方法：
	第一，既然使用锁会带来性能问题，那最好的方案自然就是使用无锁的算法和数据结构了。在这 方面有很多相关的技术，例如线程本地存储 (Thread Local Storage, TLS)、写入时复制 (Copyon-write)、乐观锁等；Java 并发包里面的原子类也是一种无锁的数据结构；Disruptor 则是一 个无锁的内存队列，性能都非常好……
	第二，减少锁持有的时间。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减 少持有锁的时间。这个方案具体的实现技术也有很多，例如使用细粒度的锁，一个典型的例子就 是 Java 并发包里的 ConcurrentHashMap，它使用了所谓分段锁的技术（这个技术后面我们会 详细介绍）；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥。
```

#### 五. 管程

​	管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发